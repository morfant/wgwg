# Redis를 활용한 온톨로지 일관성 유지 계획

이 문서는 Redis를 동적 지식 베이스로 활용하여, 다양한 분석 요청 간에 노드 명칭의 일관성을 유지하기 위한 전략을 설명합니다.

## 목표
기존에 식별된 노드 정보를 제공함으로써, LLM이 동일한 개념에 대해 중복되거나 유의어인 노드(예: "User" vs "End User")를 생성하는 것을 방지합니다.

## 전략

### 1. Redis 데이터 구조
**Redis Set**을 사용하여 고유한 노드 정보를 저장합니다. Set은 중복을 자동으로 처리하므로 이 목적에 적합합니다.

*   **Key**: `ontology:nodes`
*   **Value Format**: 노드 이름 문자열 (예: `"User"`).
    *   *결정*: 컨텍스트 윈도우 효율성을 위해 `이름(name)`만 저장합니다. 필요한 경우 LLM이 문맥에 따라 타입을 결정하도록 합니다.

### 2. 워크플로우 수정 (`api/analyze/route.ts`)

요청 흐름은 다음과 같이 변경됩니다:

1.  **컨텍스트 조회 (Fetch Context)**: LLM 호출 전, Redis의 `ontology:nodes` 집합(Set)에서 모든 멤버를 조회합니다.
2.  **프롬프트 구성 (Construct Prompt)**: 조회된 기존 노드 목록을 시스템 프롬프트에 추가합니다.
    *   *프롬프트 추가 내용*: "다음은 기존에 존재하는 온톨로지 노드 목록입니다. 텍스트의 개념이 이 목록에 있다면, 정확히 동일한 이름을 재사용하세요:" `[노드 목록]`
3.  **LLM 생성 (LLM Generation)**: LLM이 텍스트를 분석하고 노드/링크를 생성하며, 제공된 어휘(기존 노드명)를 우선적으로 사용합니다.
4.  **컨텍스트 업데이트 (Update Context)**: LLM의 응답에서 `nodes`를 추출합니다.
5.  **새 노드 저장 (Store New Nodes)**: 생성된 모든 노드 이름을 `ontology:nodes` Redis Set에 추가합니다. (Redis는 중복된 값을 무시하고 새로운 값만 추가합니다.)
6.  **응답 반환 (Return Response)**: 클라이언트에 결과를 반환합니다.

### 3. 프롬프트 엔지니어링
**재사용**과 **정확성**의 균형을 맞추기 위해 프롬프트를 세심하게 조정해야 합니다.
*   *지시 사항*: "가능한 경우 기존 노드 이름을 재사용하세요. 개념이 기존 것과 명확히 다른 경우에만 새로운 노드 이름을 도입하세요."

### 4. 확장성 고려 사항
*   **컨텍스트 윈도우**: 노드 수가 증가하면 목록이 컨텍스트 윈도우를 초과하거나 성능이 저하될 수 있습니다.
    *   *완화 방안 (추후)*: 전체 데이터베이스를 덤프하는 대신, 벡터 검색(시맨틱 검색)을 구현하여 입력 텍스트와 *관련된* 기존 노드만 조회하도록 개선할 수 있습니다. 현재는 단순 목록으로 충분합니다.

## 구현 단계

1.  **`route.ts` 수정**:
    *   기존의 "캐시 적중/미적중(Cache Hit/Miss)" 로직(전체 출력을 캐싱하던 로직)을 제거합니다.
    *   Redis에서 `smembers` (Set 조회) 로직을 추가합니다.
    *   `generateObject` 프롬프트에 목록을 주입합니다.
    *   생성 후 Redis에 `sadd` (Set 추가) 로직을 추가합니다.
    *   `lib/redis.ts`의 Redis 연결 로직은 그대로 유지합니다.

## 시나리오 예시

1.  **입력 1**: "사용자가 로그인한다."
    *   *Redis*: (비어 있음)
    *   *LLM 출력*: Node["사용자"], Node["로그인"]
    *   *Redis 업데이트*: `{"사용자", "로그인"}`

2.  **입력 2**: "고객이 결제를 진행한다."
    *   *Redis 컨텍스트*: `["사용자", "로그인"]`
    *   *프롬프트*: "... 기존 노드: 사용자, 로그인 ..."
    *   *LLM 출력*: Node["사용자"] ("고객" 대신 재사용), Node["결제"]
    *   *Redis 업데이트*: `{"사용자", "로그인", "결제"}`
